#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { VisualRegressionRunner } from '../core/VisualRegressionRunner.js';
import { StorybookDiscovery } from '../core/StorybookDiscovery.js';
import type { VisualRegressionConfig, TestResult } from '../types/index.js';
import { promises as fs } from 'fs';
import { join } from 'path';
import { spawn } from 'child_process';

const program = new Command();

program
  .name('storybook-visual-regression')
  .description('Visual regression testing tool for Storybook')
  .version('1.0.0');

// Shared runner used by multiple commands
async function runTests(options: any) {
  const startedAt = Date.now();
  // Removing spinner-based progress in favor of line-list reporter output
  const spinner = ora('Starting visual regression tests...');
  let runner: VisualRegressionRunner | undefined;

  try {
    if (options.usePlaywrightReporter) {
      await runWithPlaywrightReporter(options);
      return;
    }
    const config = createConfigFromOptions(options);

    // Ensure output directories exist
    const fs = await import('fs/promises');
    await fs.mkdir(config.snapshotPath, { recursive: true });
    await fs.mkdir(config.resultsPath, { recursive: true });

    runner = new VisualRegressionRunner(config);
    const discovery = new StorybookDiscovery(config);

    // Initializing browser
    await runner.initialize();

    // Discovering stories
    const stories = await discovery.discoverStories();

    console.log(chalk.gray(`Found ${stories.length} stories. Running tests...`));
    const results = await runner.runTests();

    await runner.cleanup();

    const totalDuration = Date.now() - startedAt;
    console.log(
      `${chalk.bold('Results:')} ${results.passed}/${
        results.total
      } passed ${chalk.gray('â€” ' + formatDuration(totalDuration))}`,
    );

    if (results.failed > 0) {
      console.log(chalk.red(`\n${results.failed} tests failed:`));
      results.results
        .filter((r: TestResult) => !r.passed)
        .forEach((result: TestResult) => {
          console.log(chalk.red(`  âœ— ${result.storyId}`));
          if (result.error) {
            console.log(chalk.gray(`     ${result.error}`));
          }
        });

      console.log(chalk.yellow('\nðŸ’¡ To update snapshots, run with --update-snapshots'));
      process.exit(1);
    } else {
      console.log(chalk.green('ðŸŽ‰ All tests passed!'));
    }
  } catch (error) {
    console.log(chalk.red('Test execution failed'));
    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
    process.exit(1);
  } finally {
    // Ensure cleanup happens even if there's an error
    try {
      if (typeof runner !== 'undefined') {
        await runner.cleanup();
      }
    } catch {}
  }
}

function formatDuration(durationMs: number): string {
  if (durationMs < 1000) {
    return `${durationMs}ms`;
  }
  const seconds = durationMs / 1000;
  if (seconds < 60) {
    return `${seconds.toFixed(seconds < 10 ? 1 : 0)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.round(seconds % 60);
  return `${minutes}m ${remainingSeconds}s`;
}

async function runWithPlaywrightReporter(options: any): Promise<void> {
  const config = createConfigFromOptions(options);

  const tmpRoot = join(process.cwd(), '.svr-playwright');
  const testsDir = join(tmpRoot, 'tests');
  const configPath = join(tmpRoot, 'playwright.config.js');
  const specPath = join(testsDir, 'storybook.spec.js');

  await fs.mkdir(testsDir, { recursive: true });

  const pwConfigJs = `
// Auto-generated by storybook-visual-regression
const { defineConfig } = require('@playwright/test');
module.exports = defineConfig({
  testDir: './tests',
  fullyParallel: true,
  retries: ${config.retries},
  workers: ${config.workers},
  reporter: 'list',
  use: {
    baseURL: '${config.storybookUrl}',
    headless: ${config.headless ? 'true' : 'false'},
    timezoneId: '${config.timezone}',
    locale: '${config.locale}',
  },
  webServer: {
    command: '${config.storybookCommand ?? 'npm run storybook'}',
    url: '${config.storybookUrl}',
    reuseExistingServer: true,
    timeout: ${config.serverTimeout},
  },
});
`;

  const specJs = `
// Auto-generated by storybook-visual-regression
const { test, expect } = require('@playwright/test');

async function getStories(baseURL) {
  const url = baseURL + '/index.json';
  const res = await fetch(url);
  const data = await res.json();
  const entries = data.entries || {};
  return Object.values(entries).filter(e => e && e.type === 'story');
}

test.describe('Storybook stories', () => {
  test('iterate all stories', async ({ page, baseURL }) => {
    const stories = await getStories(baseURL);
    for (const entry of stories) {
      await page.goto(baseURL + '/iframe.html?id=' + entry.id);
      await page.waitForLoadState('networkidle');
      await expect(page).toHaveURL(/iframe.html\?id=/);
    }
  });
});
`;

  await fs.writeFile(configPath, pwConfigJs, 'utf8');
  await fs.writeFile(specPath, specJs, 'utf8');

  console.log(chalk.gray('Running Playwright Test with reporter=list...'));
  await new Promise<void>((resolve, reject) => {
    const child = spawn(
      'npx',
      ['playwright', 'test', '--config', configPath, '--reporter', 'list'],
      {
        stdio: 'inherit',
        env: process.env,
      },
    );
    child.on('exit', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`Playwright Test exited with code ${code}`));
    });
    child.on('error', reject);
  });
}

program
  .command('test')
  .description('Run visual regression tests')
  .option('-p, --port <port>', 'Storybook server port', '9009')
  .option('-u, --url <url>', 'Storybook server URL', 'http://localhost')
  .option('-o, --output <dir>', 'Output directory for results', 'visual-regression')
  .option('-b, --browser <browser>', 'Browser to use (chromium|firefox|webkit)', 'chromium')
  .option('-t, --threshold <number>', 'Visual difference threshold (0-1)', '0.2')
  .option('-w, --workers <number>', 'Number of parallel workers', '12')
  .option('--timeout <ms>', 'Test timeout in milliseconds', '30000')
  .option('--action-timeout <ms>', 'Action timeout in milliseconds', '5000')
  .option('--navigation-timeout <ms>', 'Navigation timeout in milliseconds', '10000')
  .option('-c, --command <command>', 'Command to start Storybook server', 'npm run storybook')
  .option('--server-timeout <ms>', 'Server startup timeout in milliseconds', '60000')
  .option('--headless', 'Run in headless mode', true)
  .option('--headed', 'Run in headed mode (overrides headless)')
  .option('--disable-animations', 'Disable animations in screenshots', true)
  .option('--enable-animations', 'Enable animations in screenshots (overrides disable-animations)')
  .option('--wait-network-idle', 'Wait for network idle before capturing', true)
  .option('--no-wait-network-idle', "Don't wait for network idle")
  .option('--content-stabilization', 'Wait for content to stabilize', true)
  .option('--no-content-stabilization', "Don't wait for content stabilization")
  .option(
    '--frozen-time <time>',
    'Frozen time for deterministic results',
    '2024-01-15T10:30:00.000Z',
  )
  .option('--timezone <timezone>', 'Browser timezone', 'Europe/London')
  .option('--locale <locale>', 'Browser locale', 'en-GB')
  .option('--include <patterns>', 'Include stories matching patterns (comma-separated)')
  .option('--exclude <patterns>', 'Exclude stories matching patterns (comma-separated)')
  .option('--viewport <size>', 'Default viewport size (widthxheight)', '1024x768')
  .option('--retries <number>', 'Number of retries on failure', '2')
  .option('--update-snapshots', 'Update snapshot files instead of comparing')
  .option('--grep <pattern>', 'Run tests matching pattern')
  .option('--reporter <reporter>', 'Test reporter (line|dot|json|html)', 'line')
  .option('--use-playwright-reporter', 'Run via Playwright Test and pipe its output')
  .option('--verbose', 'Verbose output')
  .option('--max-failures <number>', 'Stop after N failures (<=0 disables)', '3')
  .action(async (options) => runTests(options));

program
  .command('install-browsers')
  .description('Install Playwright browsers')
  .option('-b, --browser <browser>', 'Browser to install (chromium|firefox|webkit|all)', 'chromium')
  .action(async (options) => {
    const spinner = ora(`Installing ${options.browser} browser...`).start();

    try {
      const { execSync } = await import('child_process');
      const browser = options.browser === 'all' ? '' : options.browser;
      execSync(`playwright install ${browser}`, { stdio: 'inherit' });

      spinner.succeed(`Successfully installed ${options.browser} browser`);
    } catch (error) {
      spinner.fail('Browser installation failed');
      console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
      process.exit(1);
    }
  });

// Update command - mirrors test but forces snapshot update and exposes key options
program
  .command('update')
  .description('Update visual regression snapshots')
  .option('-p, --port <port>', 'Storybook server port', '9009')
  .option('-u, --url <url>', 'Storybook server URL', 'http://localhost')
  .option('-o, --output <dir>', 'Output directory for results', 'visual-regression')
  .option('-b, --browser <browser>', 'Browser to use (chromium|firefox|webkit)', 'chromium')
  .option('-w, --workers <number>', 'Number of parallel workers', '12')
  .option('--locale <locale>', 'Browser locale', 'en-GB')
  .option('--timezone <timezone>', 'Browser timezone', 'Europe/London')
  .option('-c, --command <command>', 'Command to start Storybook server', 'npm run storybook')
  .option('--grep <pattern>', 'Update snapshots for stories matching pattern')
  .option('--max-failures <number>', 'Stop after N failures (<=0 disables)', '3')
  .action(async (options) => {
    options.updateSnapshots = true;
    await runTests(options);
  });

function createConfigFromOptions(options: any): VisualRegressionConfig {
  const viewportRaw = options.viewport ?? '1024x768';
  const [width, height] = String(viewportRaw).split('x').map(Number);

  return {
    storybookUrl: `${options.url}:${options.port}`,
    storybookPort: parseInt(options.port),
    storybookCommand: options.command,
    serverTimeout: parseInt(options.serverTimeout),

    viewportSizes: {
      default: { width, height },
    },
    defaultViewport: 'default',

    threshold: parseFloat(options.threshold),
    snapshotPath: `${options.output}/snapshots`,
    resultsPath: `${options.output}/results`,

    browser: options.browser,
    headless: options.headed ? false : options.headless,

    frozenTime: options.frozenTime,
    timezone: options.timezone,
    locale: options.locale,

    workers: parseInt(options.workers),
    retries: parseInt(options.retries),
    timeout: parseInt(options.timeout),

    includeStories: (() => {
      const includeList = options.include
        ? String(options.include)
            .split(',')
            .map((s: string) => s.trim())
            .filter(Boolean)
        : [];
      if (options.grep) includeList.push(String(options.grep).trim());
      return includeList.length > 0 ? includeList : undefined;
    })(),
    excludeStories: options.exclude ? options.exclude.split(',') : undefined,

    disableAnimations: options.enableAnimations ? false : options.disableAnimations,
    waitForNetworkIdle: options.waitNetworkIdle,
    contentStabilization: options.contentStabilization,
    maxFailures: parseInt(options.maxFailures ?? '3'),
  };
}

program.parse();
