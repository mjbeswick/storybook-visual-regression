#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import type { VisualRegressionConfig } from '../types/index.js';
import { promises as fs } from 'fs';
import { join } from 'path';
import { spawn } from 'child_process';

const program = new Command();

// Helper function to wait for Storybook server to be ready
async function waitForStorybookServer(url: string, timeout: number): Promise<void> {
  const startTime = Date.now();
  const maxWaitTime = timeout;

  console.log(`Waiting for Storybook server to be ready at ${url}...`);

  // Give Storybook some time to start up before we start polling
  console.log('Giving Storybook 5 seconds to start up...');
  await new Promise((resolve) => setTimeout(resolve, 5000));

  let attempt = 1;
  while (Date.now() - startTime < maxWaitTime) {
    try {
      console.log(`Checking if Storybook is ready (attempt ${attempt})...`);

      // Try the main page first (faster to respond)
      const mainResponse = await fetch(url, {
        signal: AbortSignal.timeout(3000),
      });

      if (mainResponse.ok) {
        console.log('Storybook main page is accessible, checking index.json...');

        // Now try the index.json endpoint
        const indexResponse = await fetch(`${url}/index.json`, {
          signal: AbortSignal.timeout(5000),
        });

        if (indexResponse.ok) {
          console.log(`✅ Storybook server is ready at ${url}`);
          return;
        } else {
          console.log(`Index.json not ready yet (${indexResponse.status})`);
        }
      } else {
        console.log(`Main page not ready yet (${mainResponse.status})`);
      }
    } catch (error) {
      console.log(
        `Connection attempt ${attempt} failed:`,
        error instanceof Error ? error.message : String(error),
      );
    }

    attempt++;
    await new Promise((resolve) => setTimeout(resolve, 2000));
  }

  throw new Error(
    `Storybook server did not start within ${timeout}ms. Please check if Storybook is running manually at ${url}`,
  );
}

program
  .name('storybook-visual-regression')
  .description('Visual regression testing tool for Storybook')
  .version('1.0.0');

// Shared runner used by multiple commands
async function runTests(options: any) {
  const startedAt = Date.now();

  try {
    // Always use Playwright reporter path for proper webServer handling
    await runWithPlaywrightReporter(options);
  } catch (error) {
    console.log(chalk.red('Test execution failed'));
    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
    process.exit(1);
  }
}

function formatDuration(durationMs: number): string {
  if (durationMs < 1000) {
    return `${durationMs}ms`;
  }
  const seconds = durationMs / 1000;
  if (seconds < 60) {
    return `${seconds.toFixed(seconds < 10 ? 1 : 0)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.round(seconds % 60);
  return `${minutes}m ${remainingSeconds}s`;
}

function parseCommand(command: string): { command: string; args: string[] } {
  // Handle npm run commands
  if (command.startsWith('npm run ')) {
    const script = command.replace('npm run ', '');
    return { command: 'npm', args: ['run', script] };
  }

  // Handle yarn commands
  if (command.startsWith('yarn ')) {
    const args = command.split(' ').slice(1);
    return { command: 'yarn', args };
  }

  // Handle pnpm commands
  if (command.startsWith('pnpm ')) {
    const args = command.split(' ').slice(1);
    return { command: 'pnpm', args };
  }

  // Default to shell execution for complex commands
  return { command: 'sh', args: ['-c', command] };
}

async function runWithPlaywrightReporter(options: any): Promise<void> {
  const config = createConfigFromOptions(options);

  const tmpRoot = join(process.cwd(), '.svr-playwright');
  const testsDir = join(tmpRoot, 'tests');
  const configPath = join(tmpRoot, 'playwright.config.js');
  const specPath = join(testsDir, 'storybook.spec.js');

  await fs.mkdir(testsDir, { recursive: true });

  const parsedCommand = parseCommand(config.storybookCommand ?? 'npm run storybook');

  const pwConfigJs = `
// Auto-generated by storybook-visual-regression
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  retries: ${config.retries},
  workers: ${config.workers},
  reporter: 'list',
  use: {
    baseURL: '${config.storybookUrl}',
    headless: ${config.headless ? 'true' : 'false'},
    timezoneId: '${config.timezone}',
    locale: '${config.locale}',
  },
  webServer: {
    command: '${parsedCommand.command}',
    args: ${JSON.stringify(parsedCommand.args)},
    url: '${config.storybookUrl}',
    reuseExistingServer: true,
    timeout: ${config.serverTimeout},
  },
});
`;

  const specJs = `
// Auto-generated by storybook-visual-regression
import { test, expect } from '@playwright/test';
import path from 'path';

async function waitForStorybookIndex(baseURL, timeout = 30000) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const url = baseURL + '/index.json';
      const res = await fetch(url);
      
      if (res.ok) {
        const contentType = res.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          const data = await res.json();
          return data;
        }
      }
    } catch (error) {
      // Continue waiting
    }
    
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  throw new Error('Storybook index.json not available after timeout');
}

async function getStories(baseURL) {
  const data = await waitForStorybookIndex(baseURL);
  const entries = data.entries || {};
  return Object.values(entries).filter(e => e && e.type === 'story');
}

test.describe('Storybook Visual Regression Tests', () => {
  test('visual regression for all stories', async ({ page, baseURL }) => {
    console.log('Waiting for Storybook to be ready...');
    const stories = await getStories(baseURL);
    console.log(\`Found \${stories.length} stories to test\`);
    
    for (const entry of stories) {
      console.log(\`Testing story: \${entry.title} - \${entry.name}\`);
      
      // Navigate to the story
      await page.goto(baseURL + '/iframe.html?id=' + entry.id);
      await page.waitForLoadState('networkidle');
      
      // Wait a bit for any animations to settle
      await page.waitForTimeout(1000);
      
      // Take screenshot
      const screenshotPath = path.join('visual-regression-snapshots', \`\${entry.id}.png\`);
      await page.screenshot({ 
        path: screenshotPath,
        fullPage: true 
      });
      
      console.log(\`✓ Screenshot saved: \${screenshotPath}\`);
    }
    
    console.log(\`✅ Completed visual regression tests for \${stories.length} stories\`);
  });
});
`;

  await fs.writeFile(configPath, pwConfigJs, 'utf8');
  await fs.writeFile(specPath, specJs, 'utf8');

  console.log(chalk.gray('Running Playwright Test with reporter=list...'));
  await new Promise<void>((resolve, reject) => {
    const playwrightArgs = ['playwright', 'test', '--config', configPath, '--reporter', 'list'];

    // Add workers override if specified
    if (config.workers && config.workers !== 12) {
      playwrightArgs.push('--workers', config.workers.toString());
    }

    const child = spawn('npx', playwrightArgs, {
      stdio: 'inherit',
      env: process.env,
    });
    child.on('exit', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`Playwright Test exited with code ${code}`));
    });
    child.on('error', reject);
  });
}

program
  .command('test')
  .description('Run visual regression tests')
  .option('-p, --port <port>', 'Storybook server port', '9009')
  .option('-u, --url <url>', 'Storybook server URL', 'http://localhost')
  .option('-o, --output <dir>', 'Output directory for results', 'visual-regression')
  .option('-b, --browser <browser>', 'Browser to use (chromium|firefox|webkit)', 'chromium')
  .option('-t, --threshold <number>', 'Visual difference threshold (0-1)', '0.2')
  .option('-w, --workers <number>', 'Number of parallel workers', '12')
  .option('--timeout <ms>', 'Test timeout in milliseconds', '30000')
  .option('--action-timeout <ms>', 'Action timeout in milliseconds', '5000')
  .option('--navigation-timeout <ms>', 'Navigation timeout in milliseconds', '10000')
  .option('-c, --command <command>', 'Command to start Storybook server', 'npm run storybook')
  .option('--server-timeout <ms>', 'Server startup timeout in milliseconds', '60000')
  .option('--headless', 'Run in headless mode', true)
  .option('--headed', 'Run in headed mode (overrides headless)')
  .option('--disable-animations', 'Disable animations in screenshots', true)
  .option('--enable-animations', 'Enable animations in screenshots (overrides disable-animations)')
  .option('--wait-network-idle', 'Wait for network idle before capturing', true)
  .option('--no-wait-network-idle', "Don't wait for network idle")
  .option('--content-stabilization', 'Wait for content to stabilize', true)
  .option('--no-content-stabilization', "Don't wait for content stabilization")
  .option(
    '--frozen-time <time>',
    'Frozen time for deterministic results',
    '2024-01-15T10:30:00.000Z',
  )
  .option('--timezone <timezone>', 'Browser timezone', 'Europe/London')
  .option('--locale <locale>', 'Browser locale', 'en-GB')
  .option('--include <patterns>', 'Include stories matching patterns (comma-separated)')
  .option('--exclude <patterns>', 'Exclude stories matching patterns (comma-separated)')
  .option('--viewport <size>', 'Default viewport size (widthxheight)', '1024x768')
  .option('--retries <number>', 'Number of retries on failure', '2')
  .option('--update-snapshots', 'Update snapshot files instead of comparing')
  .option('--grep <pattern>', 'Run tests matching pattern')
  .option('--reporter <reporter>', 'Test reporter (line|dot|json|html)', 'line')
  .option('--use-playwright-reporter', 'Run via Playwright Test and pipe its output')
  .option('--verbose', 'Verbose output')
  .option('--max-failures <number>', 'Stop after N failures (<=0 disables)', '3')
  .action(async (options) => runTests(options));

program
  .command('install-browsers')
  .description('Install Playwright browsers')
  .option('-b, --browser <browser>', 'Browser to install (chromium|firefox|webkit|all)', 'chromium')
  .action(async (options) => {
    const spinner = ora(`Installing ${options.browser} browser...`).start();

    try {
      const { execSync } = await import('child_process');
      const browser = options.browser === 'all' ? '' : options.browser;
      execSync(`playwright install ${browser}`, { stdio: 'inherit' });

      spinner.succeed(`Successfully installed ${options.browser} browser`);
    } catch (error) {
      spinner.fail('Browser installation failed');
      console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
      process.exit(1);
    }
  });

// Update command - mirrors test but forces snapshot update and exposes key options
program
  .command('update')
  .description('Update visual regression snapshots')
  .option('-p, --port <port>', 'Storybook server port', '9009')
  .option('-u, --url <url>', 'Storybook server URL', 'http://localhost')
  .option('-o, --output <dir>', 'Output directory for results', 'visual-regression')
  .option('-b, --browser <browser>', 'Browser to use (chromium|firefox|webkit)', 'chromium')
  .option('-w, --workers <number>', 'Number of parallel workers', '12')
  .option('--locale <locale>', 'Browser locale', 'en-GB')
  .option('--timezone <timezone>', 'Browser timezone', 'Europe/London')
  .option('-c, --command <command>', 'Command to start Storybook server', 'npm run storybook')
  .option('--grep <pattern>', 'Update snapshots for stories matching pattern')
  .option('--max-failures <number>', 'Stop after N failures (<=0 disables)', '3')
  .action(async (options) => {
    options.updateSnapshots = true;
    await runTests(options);
  });

function createConfigFromOptions(options: any): VisualRegressionConfig {
  // Extract port from storybook command if not explicitly provided
  let detectedPort = options.port;
  if (!detectedPort && options.command) {
    const portMatch = options.command.match(/-p\s+(\d+)|--port\s+(\d+)/);
    if (portMatch) {
      detectedPort = portMatch[1] || portMatch[2];
      console.log(`Detected port ${detectedPort} from storybook command`);
    }
  }

  const viewportRaw = options.viewport ?? '1024x768';
  const [width, height] = String(viewportRaw).split('x').map(Number);

  return {
    storybookUrl: `${options.url}:${detectedPort || options.port}`,
    storybookPort: parseInt(detectedPort || options.port),
    storybookCommand: options.command,
    serverTimeout: parseInt(options.serverTimeout),

    viewportSizes: {
      default: { width, height },
    },
    defaultViewport: 'default',

    threshold: parseFloat(options.threshold),
    snapshotPath: `${options.output}/snapshots`,
    resultsPath: `${options.output}/results`,

    browser: options.browser,
    headless: options.headed ? false : options.headless,

    frozenTime: options.frozenTime,
    timezone: options.timezone,
    locale: options.locale,

    workers: parseInt(options.workers),
    retries: parseInt(options.retries),
    timeout: parseInt(options.timeout),

    includeStories: (() => {
      const includeList = options.include
        ? String(options.include)
            .split(',')
            .map((s: string) => s.trim())
            .filter(Boolean)
        : [];
      if (options.grep) includeList.push(String(options.grep).trim());
      return includeList.length > 0 ? includeList : undefined;
    })(),
    excludeStories: options.exclude ? options.exclude.split(',') : undefined,

    disableAnimations: options.enableAnimations ? false : options.disableAnimations,
    waitForNetworkIdle: options.waitNetworkIdle,
    contentStabilization: options.contentStabilization,
    maxFailures: parseInt(options.maxFailures ?? '3'),
  };
}

program.parse();
